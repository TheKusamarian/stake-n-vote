{"version":3,"sources":["../src/registry.ts","../src/provider.tsx","../src/hooks/useBalance.ts","../src/hooks/useContract.ts","../src/hooks/usePSP22Balances.ts","../src/hooks/useRegisteredContract.ts","../src/hooks/useRegisteredTypedContract.ts"],"names":["registerDeployment","setDeployments","deployment","deployments","idx","contractId","networkId","registerDeployments","__async","createContext","useContext","useEffect","useRef","useState","jsx","LS_ACTIVE_ACCOUNT_ADDRESS","LS_ACTIVE_EXTENSION_ID","UseInkathonProviderContext","useInkathon","context","UseInkathonProvider","children","appName","defaultChain","connectOnInit","_deployments","apiOptions","supportedWallets","allSubstrateWallets","getSubstrateChain","isInitializing","isInitialized","isConnecting","setIsConnecting","isConnected","setIsConnected","error","setError","activeChain","setActiveChain","api","setApi","provider","setProvider","accounts","setAccounts","activeAccount","_setActiveAccount","lastActiveAccount","setLastActiveAccount","activeExtension","activeSigner","unsubscribeAccounts","initialize","chain","_chain","_api","_provider","initPolkadotJs","__spreadValues","e","message","setActiveAccount","account","prevAccount","newAccount","updateAccounts","injectedAccounts","lastActiveAccountAddress","newAccounts","_lastAccount","a","accountsAreEqual","accountArraysAreEqual","connect","wallet","isInitialConnect","_a","wallets","w","isWalletInstalled","nightlyConnect","_wallet","extension","enableWallet","unsubscribe","disconnect","disconnectApi","_b","adapter","getNightlyConnectAdapter","handler","activeExtensionId","activeAccountAddress","userWantsConnection","switchActiveChain","activeWallet","getSubstrateWallet","useBalance","address","watch","formatterOptions","balanceData","setBalanceData","unsubscribes","setUnsubscribes","updateBalanceData","data","watchBalance","prev","getBalance","ContractPromise","useContract","abi","contract","setContract","usePSP22Balances","watchPSP22Balances","getPSP22Balances","useRegisteredContract","getDeployment","useRegisteredTypedContract","Contract","registeredContract","typedContract","setTypedContract","__spreadProps"],"mappings":"6SAQO,IAAMA,GAAqB,CAChCC,EACAC,IACG,CACHD,EAAgBE,GAAgB,CAE9B,IAAMC,EAAMD,EAAY,UACtB,CAAC,CAAE,WAAAE,EAAY,UAAAC,CAAU,IACvBD,EAAW,YAAY,IAAMH,EAAW,WAAW,YAAY,GAC/DI,EAAU,YAAY,IAAMJ,EAAW,UAAU,YAAY,CACjE,EACA,OAAIE,GAAO,GAAGD,EAAY,OAAOC,EAAK,CAAC,EAGhC,CAAC,GAAGD,EAAaD,CAAU,CACpC,CAAC,CACH,EAKaK,GAAsB,CACjCN,EACAE,IACGK,EAAA,yBACD,MAAML,GAAa,QAASD,GAAeF,GAAmBC,EAAgBC,CAAU,CAAC,CAC7F,GCbA,OAGE,iBAAAO,GACA,cAAAC,GACA,aAAAC,EACA,UAAAC,EACA,YAAAC,MACK,QAuSH,cAAAC,OAAA,oBAnSG,IAAMC,EAA4B,uBAC5BC,EAAyB,oBAEhCC,GAA6BR,GAAqD,IAAI,EAK/ES,EAAc,IAAM,CAC/B,IAAMC,EAAUT,GAAWO,EAA0B,EACrD,GAAI,CAACE,EAAS,MAAM,IAAI,MAAM,uDAAuD,EACrF,OAAOA,CACT,EAcaC,GAAoD,CAAC,CAChE,SAAAC,EACA,QAAAC,EACA,aAAAC,EACA,cAAAC,EACA,YAAaC,EACb,WAAAC,EACA,iBAAAC,EAAmBC,CACrB,IAAM,CAEJ,GACE,CAACL,GACA,OAAOA,GAAiB,UAAYM,EAAkBN,CAAY,IAAM,OAEzE,MAAM,IAAI,MACR,yGACF,EAIF,IAAMO,EAAiBlB,EAAO,EAAK,EAC7BmB,EAAgBnB,EAAO,EAAK,EAC5B,CAACoB,EAAcC,CAAe,EAAIpB,EAASW,CAAa,EACxD,CAACU,EAAaC,CAAc,EAAItB,EAAS,EAAK,EAC9C,CAACuB,GAAOC,CAAQ,EAAIxB,EAAuC,EAC3D,CAACyB,EAAaC,EAAc,EAAI1B,EACnC,OAAOU,GAAiB,SACrBM,EAAkBN,CAAY,EAC9BA,CACN,EACM,CAACiB,EAAKC,CAAM,EAAI5B,EAAqB,EACrC,CAAC6B,EAAUC,CAAW,EAAI9B,EAAoC,EAC9D,CAAC+B,EAAUC,EAAW,EAAIhC,EAA4B,CAAC,CAAC,EACxD,CAACiC,EAAeC,CAAiB,EAAIlC,EAA0B,EAC/D,CAACmC,EAAmBC,EAAoB,EAAIpC,EAA0B,EACtEqC,EAAkBtC,EAA0B,EAC5CuC,EAAevC,EAAe,EAC9BwC,EAAsBxC,EAAkB,EACxC,CAACT,GAAaF,EAAc,EAAIY,EAAgC,CAAC,CAAC,EAGxEF,EAAU,IAAM,CACVc,GAAclB,GAAoBN,GAAgBwB,CAAY,CACpE,EAAG,CAAC,CAAC,EAGL,IAAM4B,EAAoBC,GAA4D9C,EAAA,wBACpFsB,EAAe,QAAU,GACzBK,EAAe,EAAK,EACpBE,EAAS,MAAS,EAElB,IAAMkB,EAASD,GAAShB,EACpBkB,EACAC,EACJ,GAAI,EACA,CAAE,IAAKD,EAAM,SAAUC,CAAU,EAAI,MAAMC,GAAeH,EAAQI,EAAA,CAClE,WAAY,GACZ,eAAgB,IACbjC,EACJ,GAEDc,GAAA,MAAAA,EAAK,aACLC,EAAOe,CAAI,EACXd,GAAA,MAAAA,EAAU,aACVC,EAAYc,CAAS,EACrB1B,EAAc,QAAU,GAGpBO,EAAY,UAAYiB,EAAO,SAAShB,GAAegB,CAAM,CACnE,OAASK,EAAG,CACV,IAAMC,EAAU,2CAChB,QAAQ,MAAMA,EAASD,CAAC,EACxBvB,EAAS,CAAE,OAAgD,QAAAwB,CAAQ,CAAC,EACpE1B,EAAe,EAAK,EACpBF,EAAgB,EAAK,EACrBQ,EAAO,MAAS,EAChBE,EAAY,MAAS,EACrBZ,EAAc,QAAU,EAC1B,CAEA,OAAAD,EAAe,QAAU,GAClB0B,CACT,GAGMM,EACJC,GACG,CACC,OAAOA,GAAY,WACrBhB,EAAmBiB,GAAgB,CACjC,IAAMC,EAAaF,EAAQC,CAAW,EACtC,OAAIC,EACF,aAAa,QAAQlD,EAA2BkD,EAAW,OAAO,EAElE,aAAa,WAAWlD,CAAyB,EAE5CkD,CACT,CAAC,GAEDlB,EAAkBgB,CAAO,EACrBA,EACF,aAAa,QAAQhD,EAA2BgD,EAAQ,OAAO,EAE/D,aAAa,WAAWhD,CAAyB,EAGvD,EAGMmD,EAAiB,CACrBC,EACAC,IACG,CACH,IAAMC,EAAcF,GAAoB,CAAC,EAEnCG,EAAeF,EACjB,CAAE,QAASA,CAAyB,EACpCpB,EAEEiB,EACJI,EAAY,KAAME,GAAMC,EAAiBD,EAAGD,CAAY,CAAC,IAAKD,GAAA,YAAAA,EAAc,IAGzEI,EAAsB7B,EAAUyB,CAAW,GAC9CxB,GAAY,IAAMwB,CAAW,EAE1BG,EAAiB1B,EAAemB,CAAU,GAC7CH,EAAiB,IAAMG,CAAU,EAEnC9B,EAAe,CAAC,CAAC8B,CAAU,CAC7B,EACAtD,EAAU,IAAM,CACVmC,GAAiB,CAAC0B,EAAiB1B,EAAeE,CAAiB,GACrEC,GAAqB,IAAMH,CAAa,CAE5C,EAAG,CAACA,CAAa,CAAC,EAGlB,IAAM4B,EAAU,CACdpB,EACAqB,EACAP,EACAQ,IACGpE,EAAA,wBA1MP,IAAAqE,EAgNI,GALAxC,EAAS,MAAS,EAClBJ,EAAgB,EAAI,EACpBE,EAAe,CAAC,CAACW,CAAa,EAG1B,EAACN,GAAA,MAAAA,EAAK,cAAgBc,GAASA,EAAM,UAAYhB,EAAY,QAAU,CACzE,IAAMkB,EAAO,MAAMH,EAAWC,CAAK,EACnC,GAAI,EAACE,GAAA,MAAAA,EAAM,aAAa,MAC1B,CAEA,GAAI,CAEF,IAAMsB,EAAUnD,EAAiB,OAAQoD,GACnC,GAACC,GAAkBD,CAAC,GAEpBH,GAAoBG,EAAE,KAAOE,EAAe,GAEjD,EACD,GAAI,EAACH,GAAA,MAAAA,EAAS,QAAQ,CACpB,IAAMjB,EAAU,6CAChB,MAAAxB,EAAS,CACP,OACA,QAAAwB,CACF,CAAC,EACK,IAAI,MAAMA,CAAO,CACzB,CAIA,IAAMqB,EADkBP,GAAUG,EAAQ,KAAMC,GAAMA,EAAE,KAAOJ,EAAO,EAAE,GACrCG,EAAQ,CAAC,EAGtCK,EAAY,MAAMC,GAAaF,EAAS5D,CAAO,EACrD4B,EAAgB,QAAUiC,EAC1B,aAAa,QAAQnE,EAAwBkE,EAAQ,EAAE,EACvD/B,EAAa,QAAUgC,GAAA,YAAAA,EAAW,QAGlCN,EAAAzB,EAAoB,UAApB,MAAAyB,EAAA,KAAAzB,GACA,IAAMiC,GAAcF,GAAA,YAAAA,EAAW,SAAS,UAAWvC,GAAa,CAC9DsB,EAAetB,EAAUwB,CAAwB,CACnD,GACAhB,EAAoB,QAAUiC,EAChC,OAASzB,EAAQ,CACf,QAAQ,MAAM,iCAAkCA,CAAC,EACjDV,EAAgB,QAAU,OAC1BC,EAAa,QAAU,OACvBhB,EAAe,EAAK,CACtB,QAAE,CACAF,EAAgB,EAAK,CACvB,CACF,GAGAtB,EAAU,IAAM,CACd6B,GAAA,MAAAA,EAAK,UAAUW,EAAa,QAC9B,EAAG,CAACX,EAAKW,EAAa,OAAO,CAAC,EAG9B,IAAMmC,EAAoBC,GAA4B/E,EAAA,wBAtQxD,IAAAqE,EAAAW,EAuQI,GAAID,EAAe,CACjB,MAAM7C,GAAA,YAAAA,EAAU,aAChB,MAAMF,GAAA,YAAAA,EAAK,aACX,aAAa,WAAWxB,CAAsB,EAC9C,aAAa,WAAWD,CAAyB,EACjD,MACF,CACA,KAAI8D,EAAA3B,EAAgB,UAAhB,YAAA2B,EAAyB,QAASI,EAAe,GAAI,CACvD,IAAMQ,EAAU,MAAMC,GAAyBpE,CAAO,EACtD,MAAMmE,GAAA,YAAAA,EAAS,YACjB,CACAtD,EAAe,EAAK,EACpB+B,EAAe,CAAC,CAAC,GACjBsB,EAAApC,EAAoB,UAApB,MAAAoC,EAAA,KAAApC,GACAA,EAAoB,QAAU,OAC9BF,EAAgB,QAAU,OAC1BC,EAAa,QAAU,OACvBpB,EAAc,QAAU,EAC1B,GAGApB,EAAU,IAAM,CACd,GAAI,CAAC6B,EAAK,OACV,IAAMmD,EAAU,IAAM,CACpBL,EAAW,CACb,EACA,OAAA9C,GAAA,MAAAA,EAAK,GAAG,eAAgBmD,GACjB,IAAM,CACXnD,GAAA,MAAAA,EAAK,IAAI,eAAgBmD,EAC3B,CACF,EAAG,CAACnD,CAAG,CAAC,EAGR7B,EAAU,IAAM,CACd,GAAIoB,EAAc,SAAWD,EAAe,QAAS,OAErD,IAAM8D,EAAoB,aAAa,QAAQ5E,CAAsB,GAAK,OACpE6E,EAAuB,aAAa,QAAQ9E,CAAyB,GAAK,OAC1E+E,EAAsBF,GAAqBC,EAE7C3C,EAEJ,OAAI0C,IACF1C,EAAkBtB,EAAoB,KAAMmD,GAAMA,EAAE,KAAOa,CAAiB,GAG9EpE,GAAiBsE,EACbpB,EAAQ,OAAWxB,EAAiB2C,EAAsB,EAAI,EAC9DxC,EAAW,EACR,IAAM,CAxTjB,IAAAwB,GAyTMA,EAAAzB,EAAoB,UAApB,MAAAyB,EAAA,KAAAzB,EACF,CACF,EAAG,CAAC,CAAC,EAGL,IAAM2C,GAA2BzC,GAA0B9C,EAAA,wBACzD,IAAMwF,EAAe9C,EAAgB,SAAW+C,GAAmB/C,EAAgB,QAAQ,IAAI,EAC/F,MAAMwB,EAAQpB,EAAO0C,CAAY,CACnC,GAEA,OACElF,GAACG,GAA2B,SAA3B,CACC,MAAO,CACL,eAAgBa,EAAe,QAC/B,cAAeC,EAAc,QAC7B,aAAAC,EACA,YAAAE,EACA,MAAAE,GACA,YAAAE,EACA,kBAAAyD,GACA,IAAAvD,EACA,SAAAE,EACA,QAAAgC,EACA,WAAAY,EACA,SAAA1C,EACA,cAAAE,EACA,gBAAiBI,EAAgB,QACjC,aAAcC,EAAa,QAC3B,iBAAAW,EACA,kBAAAd,EACA,YAAA7C,GACA,iBAAAwB,CACF,EAEC,SAAAN,EACH,CAEJ,EC3VA,OAAS,aAAAV,GAAW,YAAAE,OAAgB,QAK7B,IAAMqF,GAAa,CACxBC,EACAC,EACAC,IACgB,CAChB,GAAM,CAAE,IAAA7D,CAAI,EAAItB,EAAY,EACtB,CAACoF,EAAaC,CAAc,EAAI1F,GAAsB,CAC1D,YAAa,OACb,cAAe,EACjB,CAAuB,EACjB,CAAC2F,EAAcC,CAAe,EAAI5F,GAAkC,CAAC,CAAC,EAE5E,OAAAF,GAAU,IAAM,CACd,IAAM+F,EAAqBC,GAAsB,CAC/CJ,EAAe,IAAMI,CAAI,CAC3B,EAEA,GAAI,CAACnE,EAAK,CACRkE,EAAkB,CAAC,CAAgB,EACnC,MACF,CAEA,OAAIN,EACFQ,GAAapE,EAAK2D,EAASO,EAAmBL,CAAgB,EAAE,KAAMhB,GAAgB,CACpFoB,EAAiBI,GAAS,CAAC,GAAGA,EAAMxB,CAAW,CAAC,CAClD,CAAC,EAEDyB,GAAWtE,EAAK2D,EAASE,CAAgB,EAAE,KAAKK,CAAiB,EAG5D,IAAM,CACXF,EAAa,QAASnB,GAAgBA,GAAA,YAAAA,GAAe,EACrDoB,EAAgB,IAAM,CAAC,CAAC,CAC1B,CACF,EAAG,CAACjE,EAAK2D,CAAO,CAAC,EAEVG,CACT,EC5CA,OAAc,mBAAAS,OAAuB,yBAErC,OAAS,aAAApG,GAAW,YAAAE,OAAgB,QAM7B,IAAMmG,GAAc,CACzBC,EACAd,IACG,CACH,GAAM,CAAE,IAAA3D,EAAK,aAAAR,CAAa,EAAId,EAAY,EACpC,CAACgG,EAAUC,CAAW,EAAItG,GAAsC,EAEhEwC,EAAa,IAAY7C,EAAA,wBAC7B,GAAIwB,GAAgB,CAACQ,GAAO,CAACyE,GAAO,CAACd,EAAS,CAC5CgB,EAAY,MAAS,EACrB,MACF,CACA,GAAI,CACF,IAAMD,EAAW,IAAIH,GAAgBvE,EAAKyE,EAAKd,CAAO,EACtDgB,EAAYD,CAAQ,CACtB,OAAS9E,EAAO,CACd,QAAQ,MAAM,uCAAwCA,CAAK,CAC7D,CACF,GACA,OAAAzB,GAAU,IAAM,CACd0C,EAAW,CACb,EAAG,CAACb,EAAKR,EAAciF,EAAKd,CAAO,CAAC,EAE7B,CACL,SAAAe,EACA,QAAAf,CACF,CACF,EC5BA,OAAS,aAAAxF,GAAW,YAAAE,OAAgB,QAK7B,IAAMuG,GAAmB,CAC9BjB,EACAC,EACAC,IACuB,CACvB,GAAM,CAAE,IAAA7D,EAAK,YAAAF,CAAY,EAAIpB,EAAY,EACnC,CAACoF,EAAaC,CAAc,EAAI1F,GACpC,CAAC,CACH,EACM,CAAC2F,EAAcC,CAAe,EAAI5F,GAAkC,CAAC,CAAC,EAE5E,OAAAF,GAAU,IAAM,CACd,IAAM+F,EAAqBC,GAA6B,CACtDJ,EAAe,IAAMI,CAAI,CAC3B,EAEA,GAAI,CAACnE,GAAO,CAACF,EAAa,CACxBiE,EAAe,CAAC,CAAuB,EACvC,MACF,CAEA,GAAIH,EAAO,CACT,IAAMf,EAAcgC,GAClB7E,EACA2D,EACAO,EACApE,EAAY,QACZ+D,CACF,EACAhB,GAAeoB,EAAiBI,GAAS,CAAC,GAAGA,EAAMxB,CAAW,CAAC,CACjE,MACEiC,GAAiB9E,EAAK2D,EAAS7D,EAAY,QAAS+D,CAAgB,EAAE,KAAKK,CAAiB,EAG9F,MAAO,IAAM,CACXF,EAAa,QAASnB,GAAgBA,GAAA,YAAAA,GAAe,EACrDoB,EAAgB,IAAM,CAAC,CAAC,CAC1B,CACF,EAAG,CAACjE,EAAK2D,EAAS7D,CAAW,CAAC,EAEvBgE,CACT,EC7CO,IAAMiB,GAAwB,CAAClH,EAAoBC,IAAuB,CAC/E,GAAM,CAAE,YAAAH,EAAa,YAAAmC,CAAY,EAAIpB,EAAY,EAEjDZ,EAAYA,IAAagC,GAAA,YAAAA,EAAa,UAAW,GAEjD,IAAMpC,EAAasH,GAAcrH,GAAe,CAAC,EAAGE,EAAYC,CAAS,EAEzE,OAAO0G,GAAY9G,GAAA,YAAAA,EAAY,IAAKA,GAAA,YAAAA,EAAY,OAAO,CACzD,ECdA,OAAS,aAAAS,GAAW,YAAAE,OAAgB,QAO7B,IAAM4G,GAA6B,CACxCpH,EACAqH,EACApH,IACG,CACH,GAAM,CAAE,IAAAkC,EAAK,cAAAM,CAAc,EAAI5B,EAAY,EACrCyG,EAAqBJ,GAAsBlH,EAAYC,CAAS,EAEhE,CAACsH,EAAeC,CAAgB,EAAIhH,GAAwB,MAAS,EAC3E,OAAAF,GAAU,IAAM,CACd,GAAI,EAACgH,GAAA,MAAAA,EAAoB,UAAW,EAAC7E,GAAA,MAAAA,EAAe,UAAW,CAACN,EAAK,CACnEqF,EAAiB,MAAS,EAC1B,MACF,CAIA,IAAMD,EAAgB,IAAIF,EACxBC,EAAmB,QAAQ,SAAS,EACpC7E,EAAc,QACdN,CACF,EACAqF,EAAiBD,CAAa,CAChC,EAAG,CAACD,GAAA,YAAAA,EAAoB,QAAS7E,GAAA,YAAAA,EAAe,OAAO,CAAC,EAEjDgF,EAAAnE,EAAA,GAAKgE,GAAL,CAAyB,cAAAC,CAAc,EAChD","sourcesContent":["import { SubstrateDeployment } from '@/types'\nimport { Dispatch, SetStateAction } from 'react'\n\n/**\n * Registering the given `deployment` with the given `setDeployments` dispatcher.\n * The registry is kept unique, so if there is already one deployment with\n * equal `contractId` and `networkId` it will be replaced.\n */\nexport const registerDeployment = (\n  setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>,\n  deployment: SubstrateDeployment,\n) => {\n  setDeployments((deployments) => {\n    // Check if deployment already exists & remove\n    const idx = deployments.findIndex(\n      ({ contractId, networkId }) =>\n        contractId.toLowerCase() === deployment.contractId.toLowerCase() &&\n        networkId.toLowerCase() === deployment.networkId.toLowerCase(),\n    )\n    if (idx >= 0) deployments.splice(idx, 1)\n\n    // Add new deployment\n    return [...deployments, deployment]\n  })\n}\n\n/**\n * Registers all given `deployments` via `registerDeployment` after awaiting the promise.\n */\nexport const registerDeployments = async (\n  setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>,\n  deployments: Promise<SubstrateDeployment[]>,\n) => {\n  ;(await deployments).forEach((deployment) => registerDeployment(setDeployments, deployment))\n}\n","import { accountArraysAreEqual, accountsAreEqual, initPolkadotJs } from '@/helpers'\nimport { registerDeployments } from '@/registry'\nimport {\n  SubstrateChain,\n  SubstrateDeployment,\n  SubstrateWallet,\n  UseInkathonError,\n  UseInkathonErrorCode,\n  UseInkathonProviderContextType,\n} from '@/types'\nimport {\n  allSubstrateWallets,\n  enableWallet,\n  getSubstrateWallet,\n  isWalletInstalled,\n  nightlyConnect,\n} from '@/wallets'\nimport { ApiPromise, HttpProvider, WsProvider } from '@polkadot/api'\nimport { ApiOptions } from '@polkadot/api/types'\nimport { InjectedAccount, InjectedExtension, Unsubcall } from '@polkadot/extension-inject/types'\nimport { Signer } from '@polkadot/types/types'\nimport {\n  FC,\n  PropsWithChildren,\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\nimport { getSubstrateChain } from './chains'\nimport { getNightlyConnectAdapter } from './helpers/getNightlyAdapter'\n\nexport const LS_ACTIVE_ACCOUNT_ADDRESS = 'activeAccountAddress'\nexport const LS_ACTIVE_EXTENSION_ID = 'activeExtensionId'\n\nconst UseInkathonProviderContext = createContext<UseInkathonProviderContextType | null>(null)\n\n/**\n * Primary useInkathon hook that exposes `UseInkathonProviderContext`.\n */\nexport const useInkathon = () => {\n  const context = useContext(UseInkathonProviderContext)\n  if (!context) throw new Error('useInkathon must be used within a UseInkathonProvider')\n  return context\n}\n\n/**\n * Main provider that needs to be wrapped around the app (see README)\n * to use `useInkathon` and other hooks anywhere.\n */\nexport interface UseInkathonProviderProps extends PropsWithChildren {\n  appName: string\n  defaultChain: SubstrateChain | SubstrateChain['network']\n  connectOnInit?: boolean\n  deployments?: Promise<SubstrateDeployment[]>\n  apiOptions?: ApiOptions\n  supportedWallets?: SubstrateWallet[]\n}\nexport const UseInkathonProvider: FC<UseInkathonProviderProps> = ({\n  children,\n  appName,\n  defaultChain,\n  connectOnInit,\n  deployments: _deployments,\n  apiOptions,\n  supportedWallets = allSubstrateWallets,\n}) => {\n  // Check if default chain was provided\n  if (\n    !defaultChain ||\n    (typeof defaultChain === 'string' && getSubstrateChain(defaultChain) === undefined)\n  ) {\n    throw new Error(\n      'None or invalid `defaultChain` provided with `UseInkathonProvider`. Forgot to set environment variable?',\n    )\n  }\n\n  // Setup state variables\n  const isInitializing = useRef(false)\n  const isInitialized = useRef(false)\n  const [isConnecting, setIsConnecting] = useState(connectOnInit)\n  const [isConnected, setIsConnected] = useState(false)\n  const [error, setError] = useState<UseInkathonError | undefined>()\n  const [activeChain, setActiveChain] = useState<SubstrateChain>(\n    (typeof defaultChain === 'string'\n      ? getSubstrateChain(defaultChain)\n      : defaultChain) as SubstrateChain,\n  )\n  const [api, setApi] = useState<ApiPromise>()\n  const [provider, setProvider] = useState<WsProvider | HttpProvider>()\n  const [accounts, setAccounts] = useState<InjectedAccount[]>([])\n  const [activeAccount, _setActiveAccount] = useState<InjectedAccount>()\n  const [lastActiveAccount, setLastActiveAccount] = useState<InjectedAccount>()\n  const activeExtension = useRef<InjectedExtension>()\n  const activeSigner = useRef<Signer>()\n  const unsubscribeAccounts = useRef<Unsubcall>()\n  const [deployments, setDeployments] = useState<SubstrateDeployment[]>([])\n\n  // Register given deployments\n  useEffect(() => {\n    if (_deployments) registerDeployments(setDeployments, _deployments)\n  }, [])\n\n  // Initialize polkadot-js/api\n  const initialize = async (chain?: SubstrateChain): Promise<ApiPromise | undefined> => {\n    isInitializing.current = true\n    setIsConnected(false)\n    setError(undefined)\n\n    const _chain = chain || activeChain\n    let _api: ApiPromise | undefined\n    let _provider: WsProvider | HttpProvider | undefined\n    try {\n      ;({ api: _api, provider: _provider } = await initPolkadotJs(_chain, {\n        noInitWarn: true,\n        throwOnConnect: true,\n        ...apiOptions,\n      }))\n\n      api?.disconnect()\n      setApi(_api)\n      provider?.disconnect()\n      setProvider(_provider)\n      isInitialized.current = true\n\n      // Update active chain if switching\n      if (activeChain.network !== _chain.network) setActiveChain(_chain)\n    } catch (e) {\n      const message = 'Error while initializing Polkadot.js API'\n      console.error(message, e)\n      setError({ code: UseInkathonErrorCode.InitializationError, message })\n      setIsConnected(false)\n      setIsConnecting(false)\n      setApi(undefined)\n      setProvider(undefined)\n      isInitialized.current = false\n    }\n\n    isInitializing.current = false\n    return _api\n  }\n\n  // Set active account with local storage persistence\n  const setActiveAccount: React.Dispatch<React.SetStateAction<InjectedAccount | undefined>> = (\n    account,\n  ) => {\n    if (typeof account === 'function') {\n      _setActiveAccount((prevAccount) => {\n        const newAccount = account(prevAccount)\n        if (newAccount) {\n          localStorage.setItem(LS_ACTIVE_ACCOUNT_ADDRESS, newAccount.address)\n        } else {\n          localStorage.removeItem(LS_ACTIVE_ACCOUNT_ADDRESS)\n        }\n        return newAccount\n      })\n    } else {\n      _setActiveAccount(account)\n      if (account) {\n        localStorage.setItem(LS_ACTIVE_ACCOUNT_ADDRESS, account.address)\n      } else {\n        localStorage.removeItem(LS_ACTIVE_ACCOUNT_ADDRESS)\n      }\n    }\n  }\n\n  // Updates account list and active account\n  const updateAccounts = (\n    injectedAccounts: InjectedAccount[],\n    lastActiveAccountAddress?: string,\n  ) => {\n    const newAccounts = injectedAccounts || []\n    // Find active account in new accounts or fallback to latest account\n    const _lastAccount = lastActiveAccountAddress\n      ? { address: lastActiveAccountAddress }\n      : lastActiveAccount\n\n    const newAccount =\n      newAccounts.find((a) => accountsAreEqual(a, _lastAccount)) || newAccounts?.[0]\n\n    // Update accounts and active account\n    if (!accountArraysAreEqual(accounts, newAccounts)) {\n      setAccounts(() => newAccounts)\n    }\n    if (!accountsAreEqual(activeAccount, newAccount)) {\n      setActiveAccount(() => newAccount)\n    }\n    setIsConnected(!!newAccount)\n  }\n  useEffect(() => {\n    if (activeAccount && !accountsAreEqual(activeAccount, lastActiveAccount)) {\n      setLastActiveAccount(() => activeAccount)\n    }\n  }, [activeAccount])\n\n  // Connect to injected wallet\n  const connect = async (\n    chain?: SubstrateChain,\n    wallet?: SubstrateWallet,\n    lastActiveAccountAddress?: string,\n    isInitialConnect?: boolean,\n  ) => {\n    setError(undefined)\n    setIsConnecting(true)\n    setIsConnected(!!activeAccount)\n\n    // Make sure api is initialized & connected to provider\n    if (!api?.isConnected || (chain && chain.network !== activeChain.network)) {\n      const _api = await initialize(chain)\n      if (!_api?.isConnected) return\n    }\n\n    try {\n      // Determine installed wallets\n      const wallets = supportedWallets.filter((w) => {\n        if (!isWalletInstalled(w)) return false\n        // Prevent NightlyConnect to pop up on init when no other wallet is available\n        if (isInitialConnect && w.id === nightlyConnect.id) return false\n        return true\n      })\n      if (!wallets?.length) {\n        const message = 'No Substrate-compatible extension detected'\n        setError({\n          code: UseInkathonErrorCode.NoSubstrateExtensionDetected,\n          message,\n        })\n        throw new Error(message)\n      }\n\n      // Determine wallet to use\n      const preferredWallet = wallet && wallets.find((w) => w.id === wallet.id)\n      const _wallet = preferredWallet || wallets[0]\n\n      // Enable wallet\n      const extension = await enableWallet(_wallet, appName)\n      activeExtension.current = extension\n      localStorage.setItem(LS_ACTIVE_EXTENSION_ID, _wallet.id)\n      activeSigner.current = extension?.signer as Signer\n\n      // Query & keep listening to injected accounts\n      unsubscribeAccounts.current?.()\n      const unsubscribe = extension?.accounts.subscribe((accounts) => {\n        updateAccounts(accounts, lastActiveAccountAddress)\n      })\n      unsubscribeAccounts.current = unsubscribe\n    } catch (e: any) {\n      console.error('Error while connecting wallet:', e)\n      activeExtension.current = undefined\n      activeSigner.current = undefined\n      setIsConnected(false)\n    } finally {\n      setIsConnecting(false)\n    }\n  }\n\n  // Keep active signer up to date\n  useEffect(() => {\n    api?.setSigner(activeSigner.current as Signer)\n  }, [api, activeSigner.current])\n\n  // Disconnect\n  const disconnect = async (disconnectApi?: boolean) => {\n    if (disconnectApi) {\n      await provider?.disconnect()\n      await api?.disconnect()\n      localStorage.removeItem(LS_ACTIVE_EXTENSION_ID)\n      localStorage.removeItem(LS_ACTIVE_ACCOUNT_ADDRESS)\n      return\n    }\n    if (activeExtension.current?.name === nightlyConnect.id) {\n      const adapter = await getNightlyConnectAdapter(appName)\n      await adapter?.disconnect()\n    }\n    setIsConnected(false)\n    updateAccounts([])\n    unsubscribeAccounts.current?.()\n    unsubscribeAccounts.current = undefined\n    activeExtension.current = undefined\n    activeSigner.current = undefined\n    isInitialized.current = false\n  }\n\n  // API Disconnection listener\n  useEffect(() => {\n    if (!api) return\n    const handler = () => {\n      disconnect()\n    }\n    api?.on('disconnected', handler)\n    return () => {\n      api?.off('disconnected', handler)\n    }\n  }, [api])\n\n  // Initialize\n  useEffect(() => {\n    if (isInitialized.current || isInitializing.current) return\n\n    const activeExtensionId = localStorage.getItem(LS_ACTIVE_EXTENSION_ID) || undefined\n    const activeAccountAddress = localStorage.getItem(LS_ACTIVE_ACCOUNT_ADDRESS) || undefined\n    const userWantsConnection = activeExtensionId && activeAccountAddress\n\n    let activeExtension: SubstrateWallet | undefined\n\n    if (activeExtensionId) {\n      activeExtension = allSubstrateWallets.find((w) => w.id === activeExtensionId)\n    }\n\n    connectOnInit || userWantsConnection\n      ? connect(undefined, activeExtension, activeAccountAddress, true)\n      : initialize()\n    return () => {\n      unsubscribeAccounts.current?.()\n    }\n  }, [])\n\n  // Switch active chain\n  const switchActiveChain = async (chain: SubstrateChain) => {\n    const activeWallet = activeExtension.current && getSubstrateWallet(activeExtension.current.name)\n    await connect(chain, activeWallet)\n  }\n\n  return (\n    <UseInkathonProviderContext.Provider\n      value={{\n        isInitializing: isInitializing.current,\n        isInitialized: isInitialized.current,\n        isConnecting,\n        isConnected,\n        error,\n        activeChain,\n        switchActiveChain,\n        api,\n        provider,\n        connect,\n        disconnect,\n        accounts,\n        activeAccount,\n        activeExtension: activeExtension.current,\n        activeSigner: activeSigner.current,\n        setActiveAccount,\n        lastActiveAccount,\n        deployments,\n        supportedWallets,\n      }}\n    >\n      {children}\n    </UseInkathonProviderContext.Provider>\n  )\n}\n","import { BalanceData, BalanceFormatterOptions, getBalance, watchBalance } from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * Hook that returns the native token balance of the given `address`.\n */\nexport const useBalance = (\n  address?: string | AccountId,\n  watch?: boolean,\n  formatterOptions?: BalanceFormatterOptions,\n): BalanceData => {\n  const { api } = useInkathon()\n  const [balanceData, setBalanceData] = useState<BalanceData>({\n    tokenSymbol: 'Unit',\n    tokenDecimals: 12,\n  } satisfies BalanceData)\n  const [unsubscribes, setUnsubscribes] = useState<(VoidFunction | null)[]>([])\n\n  useEffect(() => {\n    const updateBalanceData = (data: BalanceData) => {\n      setBalanceData(() => data)\n    }\n\n    if (!api) {\n      updateBalanceData({} as BalanceData)\n      return\n    }\n\n    if (watch) {\n      watchBalance(api, address, updateBalanceData, formatterOptions).then((unsubscribe) => {\n        setUnsubscribes((prev) => [...prev, unsubscribe])\n      })\n    } else {\n      getBalance(api, address, formatterOptions).then(updateBalanceData)\n    }\n\n    return () => {\n      unsubscribes.forEach((unsubscribe) => unsubscribe?.())\n      setUnsubscribes(() => [])\n    }\n  }, [api, address])\n\n  return balanceData\n}\n","import { useInkathon } from '@/provider'\nimport { Abi, ContractPromise } from '@polkadot/api-contract'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * React Hook that returns a `ContractPromise` object configured with\n * the active api & chain as well as the given `abi` and `address`.\n */\nexport const useContract = (\n  abi?: string | Record<string, unknown> | Abi,\n  address?: string | AccountId,\n) => {\n  const { api, isConnecting } = useInkathon()\n  const [contract, setContract] = useState<ContractPromise | undefined>()\n\n  const initialize = async () => {\n    if (isConnecting || !api || !abi || !address) {\n      setContract(undefined)\n      return\n    }\n    try {\n      const contract = new ContractPromise(api, abi, address)\n      setContract(contract)\n    } catch (error) {\n      console.error('Error during Contract initialization', error)\n    }\n  }\n  useEffect(() => {\n    initialize()\n  }, [api, isConnecting, abi, address])\n\n  return {\n    contract,\n    address,\n  }\n}\n","import {\n  BalanceFormatterOptions,\n  PSP22BalanceData,\n  getPSP22Balances,\n  watchPSP22Balances,\n} from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * Hook that returns the PSP-22 token balances of the given `address`.\n */\nexport const usePSP22Balances = (\n  address?: string | AccountId,\n  watch?: boolean,\n  formatterOptions?: BalanceFormatterOptions,\n): PSP22BalanceData[] => {\n  const { api, activeChain } = useInkathon()\n  const [balanceData, setBalanceData] = useState<PSP22BalanceData[]>(\n    [] satisfies PSP22BalanceData[],\n  )\n  const [unsubscribes, setUnsubscribes] = useState<(VoidFunction | null)[]>([])\n\n  useEffect(() => {\n    const updateBalanceData = (data: PSP22BalanceData[]) => {\n      setBalanceData(() => data)\n    }\n\n    if (!api || !activeChain) {\n      setBalanceData([] as PSP22BalanceData[])\n      return\n    }\n\n    if (watch) {\n      const unsubscribe = watchPSP22Balances(\n        api,\n        address,\n        updateBalanceData,\n        activeChain.network,\n        formatterOptions,\n      )\n      unsubscribe && setUnsubscribes((prev) => [...prev, unsubscribe])\n    } else {\n      getPSP22Balances(api, address, activeChain.network, formatterOptions).then(updateBalanceData)\n    }\n\n    return () => {\n      unsubscribes.forEach((unsubscribe) => unsubscribe?.())\n      setUnsubscribes(() => [])\n    }\n  }, [api, address, activeChain])\n\n  return balanceData\n}\n","import { getDeployment } from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { useContract } from './useContract'\n\n/**\n * React Hook that returns a `ContractPromise` object configured with\n * the active api & chain with the given deployment contract id which\n * is looked up from the deployments registry.\n */\nexport const useRegisteredContract = (contractId: string, networkId?: string) => {\n  const { deployments, activeChain } = useInkathon()\n\n  networkId = networkId || activeChain?.network || ''\n\n  const deployment = getDeployment(deployments || [], contractId, networkId)\n\n  return useContract(deployment?.abi, deployment?.address)\n}\n","import { useRegisteredContract } from '@/hooks/useRegisteredContract'\nimport { useInkathon } from '@/provider'\nimport { TypechainContractConstructor } from '@/types'\nimport { useEffect, useState } from 'react'\n\n/**\n * React Hook that returns a type-safe contract object by `typechain-polkadot`,\n * configured with the active api & chain for the given deployment contract id\n * which is looked up from the deployments registry.\n */\nexport const useRegisteredTypedContract = <T>(\n  contractId: string,\n  Contract: TypechainContractConstructor<T>,\n  networkId?: string,\n) => {\n  const { api, activeAccount } = useInkathon()\n  const registeredContract = useRegisteredContract(contractId, networkId)\n\n  const [typedContract, setTypedContract] = useState<T | undefined>(undefined)\n  useEffect(() => {\n    if (!registeredContract?.address || !activeAccount?.address || !api) {\n      setTypedContract(undefined)\n      return\n    }\n\n    // IMPORTANT: Right now, only KeyringPair is supported as signer, but as we don't have\n    //            those anyways in the frontend, we can alreaday start using the new API.\n    const typedContract = new Contract(\n      registeredContract.address.toString(),\n      activeAccount.address as any,\n      api,\n    )\n    setTypedContract(typedContract)\n  }, [registeredContract?.address, activeAccount?.address])\n\n  return { ...registeredContract, typedContract }\n}\n"]}